//@author: a0111798x



	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\archive\OperationRecord.java
	 */


 /** 
 * This purpose of this class is to have a generic object which can
 * store both Task object and String object as a single record.
 * 
 * @param <T>
 *            A generic type which we used for Task Object
 * @param <S>
 *            A generic type which we used for String Object
 */
public class OperationRecord<T, S> {
	private T t;
	private S op;

	public OperationRecord(T tObj, S sObj) {
		this.t = tObj;
		this.op = sObj;
	}

	/**
	 * Method return object S
	 * @return S
	 */
	public S getOp() {
		return this.op;
	}
	/**
	 * Method return object T
	 * @return T
	 */
	public T getTask() {
		return this.t;
	}

}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\archive\OperationRecord.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\archive\Undo.java
	 */


public class Undo implements Observer {

    private Stack<OperationRecord<Task, String>> record;
    private OPLogic crudLogic = null;

    /**
     * constructor
     */
	public Undo() {
		record = new Stack<OperationRecord<Task, String>>();
		crudLogic = OPLogic.getInstance();
	}

    /**
     * Save all the operation execute by the user and task affected by the
     * command into a stack
     * 
     * @param t
     *            Task that is affected
     * @param operation
     *            Command that has been execute on the task
     */
    public void saveOperation(Task t, String operation) {
        OperationRecord<Task, String> temp = new OperationRecord<Task, String>(
                t, operation);
        record.push(temp);
    }

    /**
     * Performs undo operation for taskaler
     * 
     * @return Task
     */

    public Task undo() {
    	
		if (record.size() < 1) {
			return null;
		}
        /**
         * get the last operation records
         */
        OperationRecord<Task, String> opRecord = record.pop();
        /**
         * determine the inverse function
         */
		String operation = inverseFunction(opRecord.getOp());

		Task t = opRecord.getTask();
		Task result = null;
		switch (operation) {
		case "ADD":
			result = crudLogic.addTask(t);
			break;
		case "DELETE":
			result = crudLogic.deleteTask(t);
			break;
		case "EDIT":
			result = crudLogic.editTask(t);
			break;
		}
		return result;
    }

    /**
     * Method to help determine the opposite commands or inverse the supplied
     * commands
     * 
     * @param op
     *            commands to be inversed.
     * @return String
     */

	public String inverseFunction(String op) {
		String result = "";
		switch (op) {
		case "ADD":
			result = "DELETE";
			break;
		case "DELETE":
			result = "ADD";
			break;
		case "EDIT":
		case "DATE":
		case "COMPLETE":
		case "WORKLOAD":
		case "REPEAT":
		case "TIME":
			result = "EDIT";
			break;
		default:
		}
		return result;
	}

    /**
     * Method to display the view of all the item in the undo stack. Listing the
     * 
     * @return ArrayList<Operation<Task,String>>
     */
	public ArrayList<OperationRecord<Task, String>> viewUndo() {
		ListIterator<OperationRecord<Task, String>> itr = record.listIterator();
		return reverseOrder(itr);
	}

	public String stackToDisplay() {
		String toDisplay = "";
		ArrayList<OperationRecord<Task, String>> viewStack = viewUndo();
		for (int i = 0; i < viewStack.size(); i++) {
			Task task = viewStack.get(i).getTask();
			String taskName = task.getTaskName();
			String taskID = task.getTaskID();
			String op = viewStack.get(i).getOp();
			String msg = (i + 1) + ") Performed \"" + op + "\" on Task "
					+ taskName + " (ID=" + taskID + ")";
			if (i == viewStack.size() - 1) {
				toDisplay = toDisplay + msg;
			} else {
				toDisplay = toDisplay + msg + "\n\n";
			}
		}
		return toDisplay;
	}

    /**
     * This is to reverse the order of the stack for viewing purposes. Showing
     * the latest pushed object at the first index of the array list.
     * 
     * @param itr
     *            Iterator of the undo stack
     * @return ArrayList<OperationRecord<Task,String>>
     */
	private ArrayList<OperationRecord<Task, String>> reverseOrder(
			ListIterator<OperationRecord<Task, String>> itr) {
        /**
         * Holder variables to make the last item in the stack to be the first
         * index of the ArrayList.
         */
        ArrayList<OperationRecord<Task, String>> undoView = new ArrayList<OperationRecord<Task, String>>();
        Stack<OperationRecord<Task, String>> temp = new Stack<OperationRecord<Task, String>>();
        /**
         * Transferring items using the holder variables to make the last item
         * in the iterator to be the first item
         */
		while (itr.hasNext()) {
			temp.push(itr.next());
		}
		while (!temp.isEmpty()) {
			undoView.add(temp.pop());
		}
		return undoView;
    }

    /**
     * Override the update method of observer object to listen for any commands
     * executed by the user. Only ADD, DELETE and EDIT operation task will be
     * saved by undo function
     */
	@Override
	public void update(Observable arg0, Object arg1) {
		if (arg1 instanceof OperationRecord<?, ?>) {
			OperationRecord<Task, String> currentRecord = (OperationRecord<Task, String>) arg1;
			if (currentRecord.getOp().compareToIgnoreCase("UNDO") != 0) {
				record.push(currentRecord);
			}
		}

	}
}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\archive\Undo.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\common\configurations\Configuration.java
	 */

    /**
     * checkConfigInfo(ArrayList<String> configInfo) will check the
     * configuration information are all valid
     * 
     * @param configInfo
     * @return return null if configInfo is not valid, otherwise return
     *         configInfo
     */

    private ArrayList<String> checkConfigInfo(ArrayList<String> configInfo) {

        if (configInfo == null || configInfo.size() != NUM_OF_ATTRIBUTE) {
            return null;
        } else {
            if (configInfo.get(VIEW_POISTION).compareToIgnoreCase("list") != 0
                    && configInfo.get(VIEW_POISTION).compareToIgnoreCase(
                            "calendar") != 0
                    && configInfo.get(VIEW_POISTION).compareToIgnoreCase(
                            "today") != 0) {
            	configInfo.set(VIEW_POISTION,DEFAULT_VIEW);
            }
            if (configInfo.get(LOG_LEVEL_POSITION).compareToIgnoreCase("all") != 0
                    && configInfo.get(LOG_LEVEL_POSITION).compareToIgnoreCase(
                            "none") != 0) {
            	configInfo.set(LOG_LEVEL_POSITION,DEFAULT_LOG_LEVEL);
            }
            if (configInfo.get(WECOME_MSG_POSITION).isEmpty()) {
            	configInfo.set(WECOME_MSG_POSITION,DEFAULT_WELCOME_MSG);
            }
      
            if (!availableColor.contains(configInfo.get(ROW_COLOR_POSITION))) {
            	configInfo.set(ROW_COLOR_POSITION,DEFAULT_ROW_COLOR);
            }

            if (!availableColor.contains(configInfo.get(ALTROW_COLOR_POSITION))) {
            	configInfo.set(ALTROW_COLOR_POSITION,DEFAULT_ALTROW_COLOR);
            }

            if (!availableColor.contains(configInfo.get(TOAST_COLOR_POSITION))) {
            	configInfo.set(TOAST_COLOR_POSITION,DEFAULT_TOAST_COLOR);
            }

            if (!availableColor.contains(configInfo.get(DONE_COLOR_POSITION))) {
            	configInfo.set(DONE_COLOR_POSITION,DEFAULT_DONE_COLOR);
            }
            
            if (!availableColor.contains(configInfo.get(HEADER_COLOR_POSITION))) {
            	configInfo.set(HEADER_COLOR_POSITION,DEFAULT_HEADER_COLOR);
            }
            
            if(configInfo.get(FILENAME_POSITION).isEmpty()){
            	configInfo.set(FILENAME_POSITION,DEFAULT_FILE_NAME);
            }

            if (configInfo.get(TIMEFORMAT_POSITION).compareTo("hh:mm aa") != 0
                    && configInfo.get(TIMEFORMAT_POSITION).compareTo("HH:mm") != 0) {
            	configInfo.set(TIMEFORMAT_POSITION,DEFAULT_TIME_FORMAT);
            }
        }

        return configInfo;
    }
    
	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\common\configurations\Configuration.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\common\data\DeadLineTask.java
	 */


public class DeadLineTask extends Task {

	private Calendar _deadLine;

	public DeadLineTask() {
		super();
	}

	/**
	 * Overloaded constructor to create a new DeadLineTask object
	 *
	 * 
	 * @param taskName
	 *            Name of Task
	 * @param taskID
	 *            ID of the task
	 * @param taskStatus
	 *            Status of the task
	 * @param creationDate
	 *            Creation date of the task
	 * @param taskWorkLoad
	 *            Workload of the task
	 * @param taskDescription
	 *            Description of the task
	 * @param deadline
	 *            Deadline of the task
	 * @param start
	 *            Start time of the task
	 * @param end
	 *            end time of the task
	 */

	public DeadLineTask(String taskName, String taskID, boolean taskStatus,
			Calendar creationDate, String taskWorkLoad, String taskDescription,
			Calendar deadline, Calendar start, Calendar end) {
		super(taskName, taskID, taskStatus, creationDate, taskWorkLoad,
				taskDescription, start, end);
		this._deadLine = deadline;
	}

	/**
	 * Clone a new deadline task with the same attribute of the calling deadline
	 * task object
	 * 
	 * @return DeadLineTask
	 */
	@Override
	public DeadLineTask clone() {
		DeadLineTask newTask = new DeadLineTask(this.getTaskName(),
				this.getTaskID(), this.getTaskStatus(),
				this.getTaskCreationDate(), this.getTaskWorkLoad(),
				this.getTaskDescription(), this.getDeadline(),
				this.getStartTime(), this.getEndTime());
		return newTask;
	}

	/**
	 * Method to return the date of the deadline
	 * @return Calendar
	 */
	public Calendar getDeadline() {
		return this._deadLine;
	}

	/**
	 * A mutator method to change the date of the deadline
	 * @param date
	 * 			The new deadline date of the DeadLineTask
	 */
	public void setDeadline(Calendar date) {
		this._deadLine = date;
	}
}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\common\data\DeadLineTask.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\common\data\FloatTask.java
	 */


public class FloatTask extends Task {

	public FloatTask() {
		super();
	}

	/**
	 * Overloaded constructor to create a new FloatTask object
	 * 
	 * @param taskName
	 *            Name of the task
	 * @param taskID
	 *            ID of the task
	 * @param taskStatus
	 *            Status of the task
	 * @param creationDate
	 *            Creation date of the task
	 * @param taskWorkLoad
	 *            Workload of the task
	 * @param taskDescription
	 *            Description of the task
	 * @param start
	 *            Start time of the task
	 * @param end
	 *            End time of the task
	 */
	public FloatTask(String taskName, String taskID, boolean taskStatus,
			Calendar creationDate, String taskWorkLoad, String taskDescription,
			Calendar start, Calendar end) {
		super(taskName, taskID, taskStatus, creationDate, taskWorkLoad,
				taskDescription, start, end);
	}

	/**
	 * Clone a new float task with the same attribute of the calling float task
	 * object
	 * 
	 * @return FloatTask
	 */
	@Override
	public FloatTask clone() {
		FloatTask newTask = new FloatTask(this.getTaskName(), this.getTaskID(),
				this.getTaskStatus(), this.getTaskCreationDate(),
				this.getTaskWorkLoad(), this.getTaskDescription(),
				this.getStartTime(), this.getEndTime());
		return newTask;
	}

}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\common\data\FloatTask.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\common\data\RepeatedTask.java
	 */


public class RepeatedTask extends Task {
    
    private String _pattern;
	private ArrayList<Calendar> _repeatedDate;
	private Calendar _endRepeatedDate;
	private int _collectionID;

	public RepeatedTask() {
	}

	/**
	 * Overloaded constructor to create a new RepeatedTask object
	 * 
	 * @param taskName
	 *            Name of the task
	 * @param taskID
	 *            ID of the task
	 * @param taskStatus
	 *            Status of the task
	 * @param taskWorkLoad
	 *            Workload of the task
	 * @param taskDescription
	 *            Description of the task
	 * @param start
	 *            Start time of the task
	 * @param end
	 *            End time of the task
	 * @param repeatedDate
	 *            Date of the task to be place on a specific day of the calendar
	 *            repeatedly
	 * @param endRepeatedDate
	 *            After this date, this repeated task will be not be shown in
	 *            the calendar
	 * @param ID
	 *            This is ID for the repeated task
	 */
	public RepeatedTask(String taskName, String taskID, boolean taskStatus,
			Calendar creationDate, String taskWorkLoad, String taskDescription,
			Calendar start, Calendar end, String pattern, ArrayList<Calendar> repeatedDate,
			Calendar endRepeatedDate, int ID) {

		super(taskName, taskID, taskStatus, creationDate, taskWorkLoad,
				taskDescription, start, end);
		this._pattern = pattern;
		this._repeatedDate = repeatedDate;
		this._endRepeatedDate = endRepeatedDate;
		this._collectionID = ID;
	}

	/**
	 * Clone a new repeated task with the same attribute of the calling repeated
	 * task object
	 * 
	 * @return RepeatedTask
	 */
	@Override
	public RepeatedTask clone() {
		RepeatedTask newTask = new RepeatedTask(this.getTaskName(),
				this.getTaskID(), this.getTaskStatus(),
				this.getTaskCreationDate(), this.getTaskWorkLoad(),
				this.getTaskDescription(), this.getStartTime(),
				this.getEndTime(), this.getPattern(), this.getRepeatedDate(),
				this.getEndRepeatedDate(), this.getCollectiveID());
		return newTask;
	}

	/**
	 * Method to return the String pattern
	 * @return String
	 */
	public String getPattern() {
	    return this._pattern;
	}
	/**
	 * Method to return an array list of all the date(Calendar object)
	 * @return ArrayList<Calendar>
	 */
	public ArrayList<Calendar> getRepeatedDate() {
		return this._repeatedDate;
	}
	/**
	 * Method to return the last date of the repeating date.
	 * @return Calendar
	 */
	public Calendar getEndRepeatedDate() {
		return this._endRepeatedDate;
	}
	/**
	 * Method to return the collective ID of repeatedTask.
	 * @return int
	 */
	public int getCollectiveID() {
		return this._collectionID;
	}

	/**
	 * A mutator method that change the pattern attributes
	 * @param pattern
	 * 				The new string pattern
	 */
	public void setPattern(String pattern){
	    this._pattern = pattern;
	}
	/**
	 * A mutator method that change the array list of dates(Calendar object)
	 * @param repeat 
	 * 			The new array list of dates.
	 */
	public void setRepeatedDate(ArrayList<Calendar> repeat) {
		this._repeatedDate = repeat;
	}
	/**
	 * A mutator method that change the date of the last repeated date
	 * @param endRepeat
	 * 				The new last repeated date.
	 */
	public void setEndRepeatedDate(Calendar endRepeat) {
		this._endRepeatedDate = endRepeat;
	}
	/**
	 * A mutator method that change the collective ID
	 * @param ID
	 * 			The new collective ID for the repeatedTask.
	 */
	public void setCollectiveID(int ID) {
		this._collectionID = ID;
	}
	
	/**
	 * Change the pattern string to English representation string
	 * @param pattern
	 * 				The string pattern of the repeatedTask 
	 * @return String
	 */
	public static String patternToEnglish(String pattern){
	    String[] patternSplit = pattern.split("\\s+");
	    if(patternSplit.length == 1){
	        switch(pattern){
	        case "WEEKEND":
	            return "Weekends";
	        case "WEEKDAY":
	            return "Weekdays"; 
	        case "LAST":
	            return "Every last day";
	        }
	    } else if(patternSplit.length == 2){
	        String every = "Every ";
	        String type = patternSplit[1];
	        int variable = 0;
	        try{
	            variable = Integer.parseInt(patternSplit[0]);
	        } catch(Exception e){
	            return pattern;
	        }
	        switch(type){
	        case "DAYOFWEEK":
	            switch(variable){
	            case 1:
	                return every + "SUN";
	            case 2:
	                return every + "MON";
	            case 3:
	                return every + "TUE";
	            case 4:
	                return every + "WED";
	            case 5:
	                return every + "THU";
	            case 6:
	                return every + "FRI";
	            case 7:
	                return every + "SAT";
	            }
	        case "DAY":
	            switch(variable){
	            case 1:
	                return "Daily";
	            case 2:
	                return every + "2 days";
	            }
	        case "WEEK":
	            switch(variable){
	            case 1:
	                return "Weekly";
	            case 2:
	                return every + "2 weeks";
	            }
	        case "MONTH":
	            switch(variable){
	            case 1:
	                return "Monthly";
	            }
	        case "YEAR":
	            switch(variable){
	            case 1:
	                return "Yearly";
	            }
	        }
	    }
        return pattern;
	}
}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\common\data\RepeatedTask.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\common\data\Task.java
	 */

public abstract class Task {

	/**
	 * Possible workload values
	 */
	public static final String WORKLOAD_NONE = "0";
	public static final String WORKLOAD_LOW = "1";
	public static final String WORKLOAD_MEDIUM = "2";
	public static final String WORKLOAD_HIGH = "3";

	public enum WorkloadProperty {
		NONE, LOW, MEDIUM, HIGH
	}

	private String _taskName;
	private String _taskID;
	private boolean _taskStatus;
	private Calendar _taskStartTime;
	private Calendar _taskEndTime;
	private Calendar _creationDate;
	private WorkloadProperty _taskWorkLoad;
	private String _taskDescription;

	public Task() {
	}

	/**
	 * Overloaded constructor to create a new Task object
	 * 
	 * @param taskName
	 *            Name of the task
	 * @param taskID
	 *            ID of the task
	 * @param taskStatus
	 *            Status of the task
	 * @param taskWorkLoad
	 *            Workload of the task
	 * @param taskDescription
	 *            Description of the task
	 */
	public Task(String taskName, String taskID, boolean taskStatus,
			Calendar creationDate, String taskWorkLoad, String taskDescription,
			Calendar startTime, Calendar endTime) {

		_taskName = taskName;
		_taskID = taskID;
		_taskStatus = taskStatus;
		_taskStartTime = startTime;
		_taskEndTime = endTime;
		_creationDate = creationDate;
		_taskWorkLoad = workloadFromString(taskWorkLoad);
		_taskDescription = taskDescription;

	}

	/**
	 * Method to return the task name.
	 * @return String
	 */
	public String getTaskName() {
		return _taskName;
	}
	/**
	 * Method to return the task id.
	 * @return String
	 */
	public String getTaskID() {
		return _taskID;
	}
	/**
	 * Method to return the task status.
	 * @return boolean
	 */
	public boolean getTaskStatus() {
		return _taskStatus;
	}
	/**
	 * Method to return the start time of the task.
	 * @return Calendar
	 */
	public Calendar getStartTime() {
		return _taskStartTime;
	}
	/**
	 * Method to return the end time of the task.
	 * @return Calendar
	 */
	public Calendar getEndTime() {
		return _taskEndTime;
	}
	/**
	 * Method to return the task workload value.
	 * @return String
	 */
	public String getTaskWorkLoad() {
		return workloadToString(_taskWorkLoad);
	}
	/**
	 * Method to return the task creation date.
	 * @return Calendar
	 */
	public Calendar getTaskCreationDate() {
		return _creationDate;
	}
	/**
	 * Method to return the task description.
	 * @return String
	 */
	public String getTaskDescription() {
		return _taskDescription;
	}

	/**
	 * A mutator method to change the task name.
	 * @param newTaskName
	 * 				The new task name of the task.
	 */
	public void changeTaskName(String newTaskName) {
		_taskName = newTaskName;
	}

	/**
	 * A mutator method to change the task's status.
	 * @param newTaskStatus
	 * 				The new status of the task.
	 */
	public void changeTaskStatus(boolean newTaskStatus) {
		_taskStatus = newTaskStatus;
	}
	/**
	 * A mutator method to change the start time of the task.
	 * @param newTime
	 * 				The new start time of the task.
	 */
	public void changeStartTime(Calendar newTime) {
		_taskStartTime = newTime;
	}
	/**
	 * A mutator method to change the end time of the task.
	 * @param newTime
	 * 				The new end time of the task.
	 */
	public void changeEndTime(Calendar newTime) {
		_taskEndTime = newTime;
	}
	/**
	 * A mutator method to change the task workload value.
	 * @param newTaskWordLoad
	 * 				The new workload value of the task.
	 */
	public void changeTaskWorkLoad(String newTaskWordLoad) {
		_taskWorkLoad = workloadFromString(newTaskWordLoad);
	}
	/**
	 * A mutator method to change the task description.
	 * @param newTaskDescription
	 * 				The new description of the task.
	 */
	public void changeTaskDescription(String newTaskDescription) {
		_taskDescription = newTaskDescription;
	}

	/**
	 * Class methods
	 */
	
	/**
	 * Abstract method to create a new task object with the same values To be
	 * implemented by the subclass
	 */
	@Override
	public abstract Task clone();

	/**
	 * Method to map a string to workload property
	 * 
	 * @param input
	 *            String to be mapped
	 * @return WorkloadProperty
	 */
	protected static WorkloadProperty workloadFromString(String input) {
		if (input.compareToIgnoreCase(WORKLOAD_HIGH) == 0) {
			return WorkloadProperty.HIGH;
		} else if (input.compareToIgnoreCase(WORKLOAD_MEDIUM) == 0) {
			return WorkloadProperty.MEDIUM;
		} else if (input.compareToIgnoreCase(WORKLOAD_LOW) == 0) {
			return WorkloadProperty.LOW;
		} else {
			return WorkloadProperty.NONE;
		}
	}

	/**
	 * Method to convert a workload property to its string representation
	 * 
	 * @param workload
	 *            Property to be converted
	 * @return String
	 */
	protected static String workloadToString(WorkloadProperty workload) {
		if (workload == null) {
			return WORKLOAD_NONE;
		}
		switch (workload) {
		case HIGH:
			return WORKLOAD_HIGH;
		case MEDIUM:
			return WORKLOAD_MEDIUM;
		case LOW:
			return WORKLOAD_LOW;
		default:
			return WORKLOAD_NONE;
		}
	}
}
	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\common\data\Task.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\storage\CollectionOfTask.java
	 */

 /**
 *         This class acts as a holder class for gson. Gson requires to know the
 *         type of the object it is converting to json format. ArrayList only
 *         allows to specify one generic type. Using this class, gson will
 *         recognized all the 3 type of task correctly and are able to convert
 *         them all to json format.
 */

public class CollectionOfTask<T, Y, Z> {
	private ArrayList<T> floatArr;
	private ArrayList<Y> DeadLineArr;
	private ArrayList<Z> RepeatedArr;

	public CollectionOfTask() {
		floatArr = new ArrayList<T>();
		DeadLineArr = new ArrayList<Y>();
		RepeatedArr = new ArrayList<Z>();
	}

	/**
	 * Mutator method to change the array list
	 * @param arrList
	 * 				The new array list
	 */
	public void setFloatArr(ArrayList<T> arrList) {
		this.floatArr = arrList;
	}
	/**
	 * Mutator method to change the array list
	 * @param arrList
	 * 				The new array list
	 */
	public void setDeadLineArr(ArrayList<Y> arrList) {
		this.DeadLineArr = arrList;
	}
	/**
	 * Mutator method to change the array list
	 * @param arrList
	 * 				The new array list
	 */
	public void setRepeatedArr(ArrayList<Z> arrList) {
		this.RepeatedArr = arrList;
	}

	/**
	 * Method return the array list of T objects
	 * @return ArrayList<T>
	 */
	public ArrayList<T> getFloatArr() {
		return this.floatArr;
	}
	/**
	 * Method return the array list of Y objects
	 * @return ArrayList<Y>
	 */
	public ArrayList<Y> getDeadLineArr() {
		return this.DeadLineArr;
	}
	/**
	 * Method return the array list of Z objects
	 * @return ArrayList<Z>
	 */
	public ArrayList<Z> getRepeatedArr() {
		return this.RepeatedArr;
	}
}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\storage\CollectionOfTask.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\storage\HistoryStorage.java
	 */


public class HistoryStorage {

	private static HistoryStorage instance = null;
	private static CommonLogger log = CommonLogger.getInstance();
	private static final String STORAGE_DIR = ".\\taskaler\\";

	private HistoryStorage() {
		File dir = new File(STORAGE_DIR);
		if (!dir.exists()) {
			try {
				dir.mkdir();
			} catch (Exception e) {
				e.printStackTrace();
				System.exit(-1);
			}
		}
	}

	public static HistoryStorage getInstance() {
		if (instance == null) {
			instance = new HistoryStorage();
		}
		return instance;
	}

	/**
	 * Method to write history to the text file
	 * 
	 * @param fileName
	 *            The directory of the text file
	 * @param message
	 *            The message to be stored in the history file
	 * 
	 * @return return a boolean value indicating whether the write operation is
	 *         success or fail
	 */
	public boolean writeToHistory(String fileName, String message) {
		if (message == null || message.isEmpty() || fileName==null) {
			return false;
		}
		try {
			FileWriter fw = new FileWriter(STORAGE_DIR+fileName, true);
			fw.append(message + "\n");
			fw.close();
			return true;
		} catch (Exception e) {
			log.exceptionLogger(e, Level.SEVERE);
			return false;
		}
	}

	/**
	 * Method to read in history record from the text file
	 * 
	 * @param fileName
	 *            The directory of the text file
	 * 
	 * @return return a String of all the history records
	 */
	public String readFromHistory(String fileName) {
		if (fileName == null) {
			return null;
		}
		try {
			File f = new File(STORAGE_DIR + fileName);
			Scanner reader = new Scanner(f);
			String result = "";
			while (reader.hasNextLine()) {
				result = reader.nextLine() + "\n" + result;
			}
			reader.close();
			return result.trim();
		} catch (Exception e) {
			log.exceptionLogger(e, Level.SEVERE);
			return null;
		}
	}

}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\storage\HistoryStorage.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\storage\TaskAndConfigStorage.java
	 */


/**
 * This is the main storage class which performs storage function of Taskaler.
 * It is a singleton class.
 */
public class TaskAndConfigStorage {

    private static final String MSG_UNKNOWN_OS_VERSION = "Unknown JVM version detected";
    private static final String OS_BIT_PROPERTY = "sun.arch.data.model";
    private static final String OS_64_BIT = "64";
    private static final String OS_32_BIT = "32";
    private static CommonLogger log = CommonLogger.getInstance();
    private static TaskAndConfigStorage instance = null;
    private static File configFile = null;
    private static final String STORAGE_DIR = ".\\taskaler\\";

    // DLL Constants
    private static final String DLL_PATH_PARENT = "/lib";
    private static final String DLL_PATH_BIT_32 = "/x86";
    private static final String DLL_PATH_BIT_64 = "/x64";
    private static final String DLL_PATH_32 = "/JNILibrary.dll";
    private static final String DLL_PATH_64 = "/JNILibrary64.dll";
    private static final String DLL_PATH_MSVCR = "/msvcr120.dll";
    private static File[] libraryLoaded = null;

    /**
     * Constructors
     */
	private TaskAndConfigStorage() {

		File dir = new File(STORAGE_DIR);
		if (!dir.exists()) {
			try {
				dir.mkdir();
			} catch (Exception e) {
				e.printStackTrace();
				System.exit(-1);
			}
		}
		configFile = new File(STORAGE_DIR + "config_file");

		try {
			libraryLoaded = new File[2];
			if (is32Bit()) {
				libraryLoaded[0] = loadDll(DLL_PATH_PARENT + DLL_PATH_BIT_32,
						STORAGE_DIR, DLL_PATH_MSVCR);
				libraryLoaded[1] = loadDll(DLL_PATH_PARENT + DLL_PATH_BIT_32,
						STORAGE_DIR, DLL_PATH_32);
			} else if (is64Bit()) {
				libraryLoaded[0] = loadDll(DLL_PATH_PARENT + DLL_PATH_BIT_64,
						STORAGE_DIR, DLL_PATH_MSVCR);
				libraryLoaded[1] = loadDll(DLL_PATH_PARENT + DLL_PATH_BIT_64,
						STORAGE_DIR, DLL_PATH_64);
			} else {
				throw new Exception(MSG_UNKNOWN_OS_VERSION);
			}
		} catch (UnsatisfiedLinkError e) {
			log.exceptionLogger(e, Level.CONFIG);
		} catch (IOException e) {
			log.exceptionLogger(e, Level.WARNING);
		} catch (Exception e) {
			log.exceptionLogger(e, Level.CONFIG);
		}
	}

    /**
     * Method to check if the OS is 32-bits
     * 
     * @return True if the OS is 32-bits; False otherwise
     */
	private boolean is32Bit() {
		String jvmVer = System.getProperty(OS_BIT_PROPERTY);
		return jvmVer.compareTo(OS_32_BIT) == 0;
	}

    /**
     * Method to check if the OS is 64-bits
     * 
     * @return True if the OS is 64-bits; False otherwise
     */
	private boolean is64Bit() {
		String jvmVer = System.getProperty(OS_BIT_PROPERTY);
		return jvmVer.compareTo(OS_64_BIT) == 0;
	}

	public static TaskAndConfigStorage getInstance() {
		if (instance == null) {
			instance = new TaskAndConfigStorage();
		}
		return instance;
	}

    /**
     * Task storage method
     */

    /**
     * Method to read in task data from the text file
     * 
     * @param file
     *            The directory of the text file
     * 
     * @return return an arraylist of saved tasks from the text file
     */
	public ArrayList<Object> readFromFile(String file) {

		ArrayList<Object> result = new ArrayList<Object>();
		CollectionOfTask<FloatTask, DeadLineTask, RepeatedTask> holder = new CollectionOfTask<FloatTask, DeadLineTask, RepeatedTask>();

		try {
			FileReader reader = new FileReader(STORAGE_DIR + file);
			Gson gson = createGsonObj();
			TypeToken<CollectionOfTask<FloatTask, DeadLineTask, RepeatedTask>> typeToken = new TypeToken<CollectionOfTask<FloatTask, DeadLineTask, RepeatedTask>>() {
			};
			holder = gson.fromJson(reader, typeToken.getType());
			result.add(holder.getFloatArr());
			result.add(holder.getDeadLineArr());
			result.add(holder.getRepeatedArr());
			reader.close();
		} catch (Exception e) {
			log.exceptionLogger(e, Level.SEVERE);
			return null;
		}
		return result;
	}

    /**
     * Method to write all saved tasks information to the text file
     * 
     * @param file
     *            The directory of the text file
     * @param TaskList
     *            TaskList that contains all the task information
     * 
     * @return return a boolean indicating whether the write operation is a
     *         success or fail
     */
    public boolean writeToFile(String file, TaskList taskList) {
    	
    	if(file==null){
    		return false;
    	}

        try {
            FileWriter fw = new FileWriter(STORAGE_DIR + file);
            Gson gson = createGsonObj();
            CollectionOfTask<FloatTask, DeadLineTask, RepeatedTask> helper = prepareTaskList(taskList);
            TypeToken<CollectionOfTask<FloatTask, DeadLineTask, RepeatedTask>> typeToken = new TypeToken<CollectionOfTask<FloatTask, DeadLineTask, RepeatedTask>>() {
            };
            String output = gson.toJson(helper, typeToken.getType());
            fw.write(output);
            fw.close();
        } catch (Exception e) {
            log.exceptionLogger(e, Level.SEVERE);
            return false;
        }
        return true;
    }

    /**
     * Configuration storage method
     */

    /**
     * Method to read in configuration data from the text file
     * 
     * @param file
     *            The directory of the text file
     * 
     * @return return an config object from the text file
     */
	public ArrayList<String> readConfigFile() {

		ArrayList<String> config = new ArrayList<String>();
		try {
			if (!configFile.exists()) {
				return null;
			}
			FileReader reader = new FileReader(configFile);
			Gson gson = createGsonObj();
			TypeToken<ArrayList<String>> typeToken = new TypeToken<ArrayList<String>>() {
			};
			config = gson.fromJson(reader, typeToken.getType());
			reader.close();
		} catch (Exception e) {
			log.exceptionLogger(e, Level.SEVERE);
			return null;
		}
		return config;
	}

    /**
     * Method to write configuration information to the text file
     * 
     * @param file
     *            The directory of the text file
     * @param Config
     *            Config object which contains all the configuration data
     * 
     * @return return a boolean indicating whether the write operation is a
     *         success or fail
     */
	public boolean writeConfigFile(ArrayList<String> configArr) {
		try {
			FileWriter fw = new FileWriter(configFile);
			Gson gson = createGsonObj();
			TypeToken<ArrayList<String>> typeToken = new TypeToken<ArrayList<String>>() {
			};
			String output = gson.toJson(configArr, typeToken.getType());
			fw.write(output);
			fw.close();
		} catch (Exception e) {
			log.exceptionLogger(e, Level.SEVERE);
			return false;
		}
		return true;
	}

    /**
     * Helper methods
     */

    /**
     * Prepare the TaskList for gson to process
     * 
     * @param taskList
     *            TaskList object that contains all the tasks information
     * @return CollectionOfTask<FloatTask, DeadLineTask, RepeatedTask>
     */
	private CollectionOfTask<FloatTask, DeadLineTask, RepeatedTask> prepareTaskList(
			TaskList taskList) {
		CollectionOfTask<FloatTask, DeadLineTask, RepeatedTask> helper = new CollectionOfTask<FloatTask, DeadLineTask, RepeatedTask>();
		helper.setFloatArr(taskList.floatToArray());
		helper.setDeadLineArr(taskList.deadlineToArray());
		helper.setRepeatedArr(taskList.repeatedToArray());
		return helper;
	}

    /**
     * Method to instantiate a gson object for the reading json object from json
     * formatted file and output all saved task information in json format to
     * the text file.
     * 
     * @return return a gson object
     */
	private Gson createGsonObj() {
		GsonBuilder gsonBuilder = new GsonBuilder();
		gsonBuilder.setPrettyPrinting();
		Gson gson = gsonBuilder.create();
		return gson;
	}

    /**
     * Method to load a dll into the JVM
     * 
     * @param parent
     *            The path to the parent of the library
     * @param outputFolder
     *            The destination folder
     * @param library
     *            the library to be loaded
     * @return the file object of the library
     * @throws IOException
     *             thrown if there is an error reading the file
     */
	private File loadDll(String parent, String outputFolder, String library)
			throws IOException, UnsatisfiedLinkError {
		InputStream in = TaskAndConfigStorage.class.getResourceAsStream(parent
				+ library);
		byte[] buffer = new byte[1024];
		int read = -1;
		File windowsUserTempDirectory = new File(outputFolder);
		if (!windowsUserTempDirectory.exists()) {
			windowsUserTempDirectory.mkdir();
		}
		File temp = new File(windowsUserTempDirectory, library);
		if (temp.exists()) {
			temp.delete();
		}
		// System.out.println("Creating temp dll: " + temp.getAbsolutePath());
		FileOutputStream fos = new FileOutputStream(temp);

		while ((read = in.read(buffer)) != -1) {
			fos.write(buffer, 0, read);
		}
		fos.close();
		in.close();

		System.load(temp.getAbsolutePath());

		return temp;
	}

}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\storage\TaskAndConfigStorage.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\integration\ConfigStorageIntegrationTest.java
	 */

public class ConfigStorageIntegrationTest {
	
	private static final String CONFIG_FILE_DIR = ".\\taskaler\\config_file";
	private static final String EMPTY_STRING = "";
	public final String DEFAULT_VIEW = "today";
    public final String DEFAULT_WELCOME_MSG = "Welcome to Taskaler!";
    public final String DEFAULT_LOG_LEVEL = "all";
    public final String DEFAULT_ROW_COLOR = "#FFFFFF";
    public final String DEFAULT_ALT_ROW_COLOR = "#66CCFF";
    public final String DEFAULT_TOAST_COLOR = "#FFFF00";
    public final String DEFAULT_DONE_COLOR = "#FF6600";
    public final String DEFAULT_HEADER_COLOR = "#9966CC";
    public final String DEFAULT_FILENAME = "task_list";
    public final String DEFAULT_TIME_FORMAT = "HH:mm";
    public final String DEFAULT_DATE_FORMAT = "dd/MM/yyyy";
    
    public final String TESTCASE2_VIEW_VALUE = "abc";
    public final String TESTCASE4_ROW_VALUE = "#FF0000";
    public final String TESTCASE5_ROW_VALUE = "#3366FF";
    public final String TESTCASE5_FILENAME = "hello.txt";
    public final String TESTCASE5_INVALID_TIME_FORMAT = "dd:dd";
	/**
	 * Equivalence Partition: Invalid values, Valid values, empty value
	 * Boundary Analysis: change all values, change 1 value, change more than 1
	 * value but not all values
	 */

	/**
	 * Combination:
	 * Equivalence Partition: Empty value
	 * Boundary Analysis: Change all values
	 */
	@Test
	public void test1() {
		boolean switch1 = false;

		Configuration config = Configuration.getInstance();
		config.setDefaultFileName(EMPTY_STRING);
		config.setDefaultLogLevel(EMPTY_STRING);
		config.setDefaultRowColor(EMPTY_STRING);
		config.setDefaultAltRowColor(EMPTY_STRING);
		config.setDefaultToastColor(EMPTY_STRING);
		config.setDefaultView(EMPTY_STRING);
		config.setTimeFormat(EMPTY_STRING);
		config.setDefaultWelcomeMsg(EMPTY_STRING);
		config.setDefaultDoneColor(EMPTY_STRING);
		config.setDefaultHeaderColor(EMPTY_STRING);
		config.storeConfigInfo();

		Configuration readConfig = config.getInstance();
		readConfig.loadConfiguration();
		if (readConfig.getDefaultFileName().equals(DEFAULT_FILENAME)
				&& readConfig.getLogLevel().equals(DEFAULT_LOG_LEVEL)
				&& readConfig.getDefaultRowColor().equals(DEFAULT_ROW_COLOR)
				&& readConfig.getDefaultAltRowColor().equals(
						DEFAULT_ALT_ROW_COLOR)
				&& readConfig.getDefaultToastColor()
						.equals(DEFAULT_TOAST_COLOR)
				&& readConfig.getDefaultDoneColor().equals(DEFAULT_DONE_COLOR)
				&& readConfig.getDefaultHeaderColor().equals(
						DEFAULT_HEADER_COLOR)
				&& readConfig.getWelcomeMsg().equals(DEFAULT_WELCOME_MSG)
				&& readConfig.getDefaultView().equals(DEFAULT_VIEW)
				&& readConfig.getTimeFormat().equals(DEFAULT_TIME_FORMAT)) {
			switch1 = true;
		}
		assertTrue(switch1);
	}
	/**
	 * Combination:
	 * Equivalence Partition: Invalid values
	 * Boundary Analysis: Change 1 value
	 */
	@Test
	public void test2() {
		boolean switch1 = false;

		Configuration config = Configuration.getInstance();
		config.setDefaultView(TESTCASE2_VIEW_VALUE);
		config.storeConfigInfo();
		Configuration readConfig = config.getInstance();
		readConfig.loadConfiguration();
		if (readConfig.getDefaultView().equals(DEFAULT_VIEW)
				&& readConfig.getLogLevel().equals(DEFAULT_LOG_LEVEL)
				&& readConfig.getDefaultRowColor().equals(DEFAULT_ROW_COLOR)
				&& readConfig.getDefaultAltRowColor().equals(
						DEFAULT_ALT_ROW_COLOR)
				&& readConfig.getDefaultToastColor()
						.equals(DEFAULT_TOAST_COLOR)
				&& readConfig.getDefaultDoneColor().equals(DEFAULT_DONE_COLOR)
				&& readConfig.getDefaultHeaderColor().equals(
						DEFAULT_HEADER_COLOR)
				&& readConfig.getWelcomeMsg().equals(DEFAULT_WELCOME_MSG)
				&& readConfig.getDefaultFileName().equals(DEFAULT_FILENAME)
				&& readConfig.getTimeFormat().equals(DEFAULT_TIME_FORMAT)) {
			switch1 = true;
		}
		assertTrue(switch1);
	}
	/**
	 * Combination:
	 * Equivalence Partition: Invalid values
	 * Boundary Analysis: Change all 8 values (empty the file content)
	 */
	@Test
	public void test3() {
		boolean switch1 = false;

		Configuration config = Configuration.getInstance();

		/**
		 * empty the file content
		 */
		try {
			String holder = EMPTY_STRING;
			FileWriter fw = new FileWriter(CONFIG_FILE_DIR);
			fw.write(holder);
			fw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		Configuration readConfig = config.getInstance();
		readConfig.loadConfiguration();
		if (readConfig.getDefaultFileName().equals(DEFAULT_FILENAME)
				&& readConfig.getDefaultRowColor().equals(DEFAULT_ROW_COLOR)
				&& readConfig.getLogLevel().equals(DEFAULT_LOG_LEVEL)
				&& readConfig.getDefaultAltRowColor().equals(
						DEFAULT_ALT_ROW_COLOR)
				&& readConfig.getDefaultToastColor()
						.equals(DEFAULT_TOAST_COLOR)
				&& readConfig.getDefaultDoneColor().equals(DEFAULT_DONE_COLOR)
				&& readConfig.getDefaultHeaderColor().equals(
						DEFAULT_HEADER_COLOR)
				&& readConfig.getWelcomeMsg().equals(DEFAULT_WELCOME_MSG)
				&& readConfig.getDateFormat().equals(DEFAULT_DATE_FORMAT)
				&& readConfig.getDefaultView().equals(DEFAULT_VIEW)
				&& readConfig.getTimeFormat().equals(DEFAULT_TIME_FORMAT)) {
			switch1 = true;
		}
		assertTrue(switch1);

	}
	/**
	 * Combination:
	 * Equivalence Partition: Valid Values
	 * Boundary Analysis: Change 1 value
	 */
	@Test
	public void test4() {
		boolean switch1 = false;
		Configuration config = Configuration.getInstance();
		config.setDefaultRowColor(TESTCASE4_ROW_VALUE); // red
		config.storeConfigInfo();

		Configuration readConfig = config.getInstance();
		readConfig.loadConfiguration();
		if (readConfig.getDefaultFileName().equals(DEFAULT_FILENAME)
				&& readConfig.getDefaultRowColor().equals(TESTCASE4_ROW_VALUE)
				&& readConfig.getDefaultAltRowColor().equals(
						DEFAULT_ALT_ROW_COLOR)
				&& readConfig.getDefaultToastColor()
						.equals(DEFAULT_TOAST_COLOR)
				&& readConfig.getDefaultDoneColor().equals(DEFAULT_DONE_COLOR)
				&& readConfig.getDefaultHeaderColor().equals(
						DEFAULT_HEADER_COLOR)
				&& readConfig.getLogLevel().equals(DEFAULT_LOG_LEVEL)
				&& readConfig.getWelcomeMsg().equals(DEFAULT_WELCOME_MSG)
				&& readConfig.getDefaultView().equals(DEFAULT_VIEW)
				&& readConfig.getTimeFormat().equals(DEFAULT_TIME_FORMAT)) {
			switch1 = true;
		}
		assertTrue(switch1);
	}
	/**
	 * Combination:
	 * Equivalence Partition: mixture Valid and Invalid values
	 * Boundary Analysis: Change 3 value
	 */
	@Test
	public void test5() {
		boolean switch1 = false;
		Configuration config = Configuration.getInstance();
		config.setDefaultFileName(TESTCASE5_FILENAME); // valid
		config.setDefaultRowColor(TESTCASE5_ROW_VALUE); // blue, valid
		config.setTimeFormat(TESTCASE5_INVALID_TIME_FORMAT);// invalid
		config.storeConfigInfo();

		Configuration readConfig = config.getInstance();
		readConfig.loadConfiguration();
		if (readConfig.getDefaultFileName().equals(TESTCASE5_FILENAME)
				&& readConfig.getDefaultRowColor().equals(TESTCASE5_ROW_VALUE)
				&& readConfig.getDefaultView().equals(DEFAULT_VIEW)
				&& readConfig.getDefaultAltRowColor().equals(
						DEFAULT_ALT_ROW_COLOR)
				&& readConfig.getDefaultToastColor()
						.equals(DEFAULT_TOAST_COLOR)
				&& readConfig.getDefaultDoneColor().equals(DEFAULT_DONE_COLOR)
				&& readConfig.getDefaultHeaderColor().equals(
						DEFAULT_HEADER_COLOR)
				&& readConfig.getWelcomeMsg().equals(DEFAULT_WELCOME_MSG)
				&& readConfig.getLogLevel().equals(DEFAULT_LOG_LEVEL)
				&& readConfig.getTimeFormat().equals(DEFAULT_TIME_FORMAT)) {
			switch1 = true;
		}
		assertTrue(switch1);
	}
}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\integration\ConfigStorageIntegrationTest.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\integration\OPLogicUndoIntegrationTest.java
	 */

public class OPLogicUndoIntegrationTest {
	

	private static final String EDITED_DESCRIPTION = "Edited task 1.";
	private static final String EDITED_NAME = "Edited task name";
	private static final String TASK3_WORKLOAD = "3";
	private static final String TASK3_END_TIME = "23:15";
	private static final String TASK3_START_TIME = "07:45";
	private static final String TASK3_CREATION_DATE = "08/11/2014";
	private static final String TASK3_DESCRIPTION = "Test task 3";
	private static final String TASK3_NAME = "Task 3";
	private static final String TASK2_WORKLOAD = "1";
	private static final String TASK2_END_TIME = "22:59";
	private static final String TASK2_START_TIME = "19:00";
	private static final String TASK2_CREATION_DATE = "07/11/2014";
	private static final String TASK2_DESCRIPTION = "Test task 2";
	private static final String TASK2_NAME = "Task 2";
	private static final String TASK1_NAME = "Task 1";
	private static final String TASK1_WORKLOAD = "2";
	private static final String TASK1_END_TIME = "23:59";
	private static final String TASK1_START_TIME = "09:00";
	private static final String TASK1_CREATION_DATE = "06/11/2014";
	private static final String TASK1_DESCRIPTION = "Test task 1";
	/**
	 * Test undo method in the Undo class interacting with OPLogic class
	 * Equivalence Partition: no tasks in the undo stack, more than 1 task in 
	 * the undo stack
	 */
	
	
	/**
	 * Equivalence Partition: no task in the undo stack.(no command is executed)
	 */
	@Test
	public void test() {
		boolean switch1 = false;
		Undo undoObj = new Undo();
		Task result = undoObj.undo();
		if (result == null) {
			switch1 = true;
		}
		assertTrue(switch1);
	}
	
	/**
	 * Test case: User executes two add commands, a delete command and lastly a undo command.
	 * Equivalence Partition: more than 1 task in the undo stack
	 */
	@Test
	public void test2() {
		boolean switch1 = false;
		Undo undoObj = new Undo();
		OPLogic logic = OPLogic.getInstance();
		logic.addObserver(undoObj);
		Task task1 = logic.addTask(TASK1_NAME, TASK1_DESCRIPTION,
				TASK1_CREATION_DATE, TASK1_START_TIME, TASK1_END_TIME,
				TASK1_WORKLOAD);
		Task task2 = logic.addTask(TASK2_NAME, TASK2_DESCRIPTION,
				TASK2_CREATION_DATE, TASK2_START_TIME, TASK2_END_TIME,
				TASK2_WORKLOAD);
		logic.deleteTask(task1.getTaskID());
		Task result = undoObj.undo();
		if (result.getTaskName().equals(TASK1_NAME)) {
			switch1 = true;
		}
		assertTrue(switch1);
	}
	/**
	 * Test case: Users executes one add command, a edit command and lastly a undo command.
	 * Equivalence Partition: 1 task in the undo stack
	 */
	@Test
	public void test3() {
		boolean switch1 = false;
		Undo undoObj = new Undo();
		OPLogic logic = OPLogic.getInstance();
		logic.addObserver(undoObj);
		Task task3 = logic.addTask(TASK3_NAME, TASK3_DESCRIPTION,
				TASK3_CREATION_DATE, TASK3_START_TIME, TASK3_END_TIME,
				TASK3_WORKLOAD);
		logic.editTask(task3.getTaskID(), EDITED_NAME, EDITED_DESCRIPTION);
		undoObj.undo();
		SearchLogic search = new SearchLogic();
		Task result = search.findByID(task3.getTaskID());
		if (result.getTaskName().equals(TASK3_NAME)) {
			switch1 = true;
		}
		assertTrue(switch1);
	}
}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\integration\OPLogicUndoIntegrationTest.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\system\SystemTest.java
	 */


public class SystemTest {
	
	private static final String CHANGED_TASK_NAME = "changedTaskName";
	private static final String TESTCASE4_CMD6 = "delete 3";
	private static final String TESTCASE4_CMD5 = "edit changedTaskName";
	private static final String TESTCASE4_CMD4 = "repeat 3 monday, to 24/11/2014";
	private static final String TESTCASE4_CMD3 = "add task3 :It is a repeated task, 3/11/2014, 3";
	private static final String TESTCASE4_CMD2 = "add task2 :It is a deadline task, 29/10/2014, 2";
	private static final String FAILED_MSG_3 = "Integration test case 4 failed";
	private static final String FAILED_MSG_2 = "Failed empty command test";
	private static final String EMPTY_STRING = " ";
	private static final String FAILED_MSG_1 = "Failed illegal command test";
	private static final String TESTCASE2_CMD1 = "illegal command";
	private static final String TASK2_NAME = "task2";
	private static final String TASK1_NAME = "task1";
	private static final String TESTCASE1_RESULT1 = "changedTask3";
	private static final String UNDO_COMMAND = "undo";
	private static final String TESTCASE1_CMD5 = "delete 1";
	private static final String TESTCASE1_CMD4 = "edit changedTask3";
	private static final String TESTCASE1_CMD3 = "add task3 :It is a deadline task, 29/10/2014, 2";
	private static final String TESTCASE1_CMD2 = "add task2 :It is a float task2";
	private static final String COMMON_ADD_CMD = "add task1 :It is a float task";

	/**
	 * The file name should be the same as the file name state in the configuration file.
	 */
	private static final String TASK_LIST_FILE = "task_list";

	@Rule
	public JavaFXThreadingRule javafxRule = new JavaFXThreadingRule();

	static Controller controller = null;

	@After
	public void tearDownAfterClass() throws Exception {
		File f = new File(".\\taskaler\\" + TASK_LIST_FILE);
		if (f.exists()) {
			f.delete();
		}
		controller = null;
	}

	@Before
	public void setUp() {
		controller = Controller.getInstance();
	}
    /**
     * Equivalence Partition: Invalid Command, Empty Command, Valid Command
     * Boundary Analysis: 0,1 or more than 1 tasks
     */

    /**
     * Integration test 1
     * 
     * Test case: Add 2 float task and 1 deadline task. Change the task name of
     * the deadline task to changedTask3. Then, delete one float task. Execute
     * undo command.
     * 
     * Equivalence Partition: valid command
     * Boundary Analysis: more than 1 tasks
     * 
     * Expected result: There are 2 float tasks and an edited deadline task with
     * the name changedTask3.
     */
	@Test
	public void test1() {
		TaskAndConfigStorage storeObj = TaskAndConfigStorage.getInstance();
		try {
			controller.start(new Stage());
		} catch (IOException e) {
			fail(e.getMessage());
		}
		/**
		 * Clear the file content for this test case
		 */
		TaskList taskList = TaskList.getInstance();
		taskList.clear();
		storeObj.writeToFile(TASK_LIST_FILE, taskList);

		boolean switch1 = false;
		boolean switch2 = false;

		controller.executeCMD(COMMON_ADD_CMD);
		controller.executeCMD(TESTCASE1_CMD2);
		controller.executeCMD(TESTCASE1_CMD3);
		controller.executeCMD(TESTCASE1_CMD4);
		controller.executeCMD(TESTCASE1_CMD5);
		controller.executeCMD(UNDO_COMMAND);

		ArrayList<Object> tempArr = storeObj.readFromFile(TASK_LIST_FILE);
		ArrayList<FloatTask> floatArr = (ArrayList<FloatTask>) tempArr.get(0);
		ArrayList<DeadLineTask> deadlineArr = (ArrayList<DeadLineTask>) tempArr
				.get(1);

		if (deadlineArr.get(0).getTaskName().equals(TESTCASE1_RESULT1)) {
			switch1 = true;
		}

		if (floatArr.size() == 2) {
			if (floatArr.get(0).getTaskName().equals(TASK1_NAME)
					&& floatArr.get(1).getTaskName().equals(TASK2_NAME)) {
				switch2 = true;
			}
		}
		assertTrue((switch1 && switch2));
		/**
		 * Clear the file content for other test case
		 */
		taskList = TaskList.getInstance();
		taskList.clear();
		storeObj.writeToFile(TASK_LIST_FILE, taskList);
	}

    /**
     * Integration test 2
     * 
     * Test case: Executes any invalid command
     * 
     * Equivalence Partition: Invalid Command
     * Boundary Analysis: 0 task
     * 
     * Expected result: There should not have any changes to the tasklist and
     * the components should not crash
     */
	@Test
	public void test2() {
		try {
			controller.start(new Stage());
		} catch (IOException e) {
			fail(e.getMessage());
		}

		controller.executeCMD(TESTCASE2_CMD1);

		TaskAndConfigStorage storeObj = TaskAndConfigStorage.getInstance();
		ArrayList<Object> tempArr = storeObj.readFromFile(TASK_LIST_FILE);
		ArrayList<FloatTask> floatArr = (ArrayList<FloatTask>) tempArr.get(0);
		ArrayList<DeadLineTask> deadlineArr = (ArrayList<DeadLineTask>) tempArr
				.get(1);
		ArrayList<RepeatedTask> repeatedArr = (ArrayList<RepeatedTask>) tempArr
				.get(2);

		if (floatArr.size() == 0 && deadlineArr.size() == 0
				&& repeatedArr.size() == 0) {
			assertTrue(true);
		} else {
			fail(FAILED_MSG_1);
		}

	}
    /**
     * Integration 3
     * 
     * Test Case: Execute an empty command
     * 
     * Equivalence Partition: Empty Command
     * Boundary Analysis: 0 task
     * 
     * Expected Result: No changes are made to TaskList and program should not crash.
     */
	@Test
	public void test3() {
		try {
			controller.start(new Stage());
		} catch (IOException e) {
			fail(e.getMessage());
		}

		String cmd1 = EMPTY_STRING;

		TaskAndConfigStorage storeObj = TaskAndConfigStorage.getInstance();
		ArrayList<Object> tempArr = storeObj.readFromFile(TASK_LIST_FILE);
		ArrayList<FloatTask> floatArr = (ArrayList<FloatTask>) tempArr.get(0);
		ArrayList<DeadLineTask> deadlineArr = (ArrayList<DeadLineTask>) tempArr
				.get(1);
		ArrayList<RepeatedTask> repeatedArr = (ArrayList<RepeatedTask>) tempArr
				.get(2);

		int floatNum = floatArr.size();
		int deadlineNum = deadlineArr.size();
		int repeatedNum = repeatedArr.size();

		controller.executeCMD(cmd1);

		storeObj = TaskAndConfigStorage.getInstance();
		tempArr = storeObj.readFromFile(TASK_LIST_FILE);
		floatArr = (ArrayList<FloatTask>) tempArr.get(0);
		deadlineArr = (ArrayList<DeadLineTask>) tempArr.get(1);
		repeatedArr = (ArrayList<RepeatedTask>) tempArr.get(2);

		if (floatArr.size() == floatNum && deadlineArr.size() == deadlineNum
				&& repeatedArr.size() == repeatedNum) {
			assertTrue(true);
		} else {
			fail(FAILED_MSG_2);
		}
	}
    /**
     * Integration test 4
     * 
     * Test case: Add 1 float task, 1 deadline task and 1 repeated task. Change the task name of
     * the repeated task to changedTaskName. Then, delete the repeated task. Execute undo command.
     * 
     * Equivalence Partition: valid command
     * Boundary Analysis: 1 task in each arraylist
     * 
     * Expected result: There are 1 float task, 1 deadline task and 1 edited repeated task with
     * the name changedTaskName.
     */
	@Test
	public void test4() {
		try {
			controller.start(new Stage());
		} catch (IOException e) {
			fail(e.getMessage());
		}

		controller.executeCMD(COMMON_ADD_CMD);
		controller.executeCMD(TESTCASE4_CMD2);
		controller.executeCMD(TESTCASE4_CMD3);
		controller.executeCMD(TESTCASE4_CMD4);
		controller.executeCMD(TESTCASE4_CMD5);
		controller.executeCMD(TESTCASE4_CMD6);
		controller.executeCMD(UNDO_COMMAND);

		TaskAndConfigStorage storeObj = TaskAndConfigStorage.getInstance();
		ArrayList<Object> tempArr = storeObj.readFromFile(TASK_LIST_FILE);
		ArrayList<FloatTask> floatArr = (ArrayList<FloatTask>) tempArr.get(0);
		ArrayList<DeadLineTask> deadlineArr = (ArrayList<DeadLineTask>) tempArr
				.get(1);
		ArrayList<RepeatedTask> repeatedArr = (ArrayList<RepeatedTask>) tempArr
				.get(2);
		if (floatArr.get(0).getTaskName().equals(TASK1_NAME)
				&& deadlineArr.get(0).getTaskName().equals(TASK2_NAME)
				&& repeatedArr.get(0).getTaskName().equals(CHANGED_TASK_NAME)) {
			assertTrue(true);
		} else {
			fail(FAILED_MSG_3);
		}

		/**
		 * Clear the file content for other test case
		 */
		TaskList taskList = TaskList.getInstance();
		taskList.clear();
		storeObj.writeToFile(TASK_LIST_FILE, taskList);
	}
}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\system\SystemTest.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\units\HistoryStorageTestUnit.java
	 */


public class HistoryStorageTestUnit {

	private static final String FILE_DIR = ".\\taskaler\\history.txt";
	private static final String MSG_1 = "message1";
	private static final String LINE_1 = "line1";
	private static final String EMPTY_STRING = " ";
	private static final String LINE_2 = "line2";
	private static final String HISTORY_TXT = "history.txt";

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		File f = new File(FILE_DIR);
		f.delete();
	}
	
	/**
	 * Equivalence Partition(file name parameter): null file name, empty file name,
	 * non-empty file name.
	 * Equivalence Partition(message parameter): null message, empty message, 
	 * non-empty message.
	 */

	/**
	 * Write Method
	 * Combination:
	 * Equivalence Partition(file name parameter): null file name
	 * Equivalence Partition(message parameter): non-empty message
	 */
	@Test
	public void test() {
		HistoryStorage historyObj = HistoryStorage.getInstance();
		boolean result = historyObj.writeToHistory(null, MSG_1);
		assertFalse(result);
	}

	/**
	 * Write Method
	 * Combination:
	 * Equivalence Partition(file name parameter): non-empty file name
	 * Equivalence Partition(message parameter): null message
	 */
	@Test
	public void test2() {
		HistoryStorage historyObj = HistoryStorage.getInstance();
		boolean result = historyObj.writeToHistory(HISTORY_TXT, null);
		assertFalse(result);
	}
	
	/**
	 * Write Method
	 * Combination:
	 * Equivalence Partition(file name parameter): non-empty file name
	 * Equivalence Partition(message parameter): empty message
	 */
	@Test
	public void test3() {
		HistoryStorage historyObj = HistoryStorage.getInstance();
		boolean result = historyObj.writeToHistory(HISTORY_TXT, EMPTY_STRING);
		assertTrue(result);
	}

	/**
	 * read method
	 * Combination:
	 * Equivalence Partition(file name parameter): null file name
	 */
	@Test
	public void test4() {
		HistoryStorage historyObj = HistoryStorage.getInstance();
		String result = historyObj.readFromHistory(null);
		assertEquals(null, result);
	}
	
	/**
	 * read method
	 * Combination:
	 * Equivalence Partition(file name parameter): empty file name
	 */
	@Test
	public void test5() {
		HistoryStorage historyObj = HistoryStorage.getInstance();
		String result = historyObj.readFromHistory(EMPTY_STRING);
		assertEquals(null, result);
	}
	
	/**
	 * Both read and write methods
	 * Combination:
	 * Equivalence Partition(file name parameter): non-empty file name
	 * Equivalence Partition(message parameter): empty message
	 */
	@Test
	public void test6() {
		boolean switch1 = false;
		HistoryStorage store = HistoryStorage.getInstance();
		store.writeToHistory(HISTORY_TXT, EMPTY_STRING);
		store.writeToHistory(HISTORY_TXT, LINE_2);
		String result = store.readFromHistory(HISTORY_TXT);
		if (result.split("\n")[0].equals(LINE_2)) {
			switch1 = true;
		}
		assertTrue(switch1);
	}

	/**
	 * Both read and write methods
	 * Combination:
	 * Equivalence Partition(file name parameter): non-empty file name
	 * Equivalence Partition(message parameter): non-empty message
	 */
	@Test
	public void test7() throws IOException {
		boolean switch1 = false;
		HistoryStorage store = HistoryStorage.getInstance();
		store.writeToHistory(HISTORY_TXT, LINE_1);
		store.writeToHistory(HISTORY_TXT, LINE_2);

		String result = store.readFromHistory(HISTORY_TXT);
		if (result.split("\n")[1].equals(LINE_1)
				&& result.split("\n")[0].equals(LINE_2)) {
			switch1 = true;
		}
		assertTrue(switch1);
	}

}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\units\HistoryStorageTestUnit.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\units\StorageConfigTestUnit.java
	 */

public class StorageConfigTestUnit {

	
	private static final String STRING_3 = "testing 123";
	private static final String STRING_2 = "abc";
	/**
	 * Boundary Analysis: empty array list, array list with one or more strings
	 */
	
	private static final String STRING_1 = "black";
	/**
	 * Test for empty array list
	 * Boundary Analysis: empty array list
	 */
	@Test
	public void test1() {
		boolean switch1 = false;

		ArrayList<String> testArr = new ArrayList<String>();
		TaskAndConfigStorage storeObj = TaskAndConfigStorage.getInstance();
		storeObj.writeConfigFile(testArr);

		ArrayList<String> result = storeObj.readConfigFile();

		if (result.size() == 0) {
			switch1 = true;
		}
		assertTrue(switch1);
	}
	/**
	 * Test for correctness of the string object insert into the array list
	 * Boundary Analysis: array list with more than 1 string object
	 */
	@Test
	public void test2() {
		boolean switch1 = false;

		ArrayList<String> testArr = new ArrayList<String>();
		testArr.add(STRING_1);
		testArr.add(STRING_2);
		testArr.add(STRING_3);
		TaskAndConfigStorage storeObj = TaskAndConfigStorage.getInstance();
		storeObj.writeConfigFile(testArr);

		ArrayList<String> result = storeObj.readConfigFile();

		if (result.size() > 0 && testArr.get(0).equals(STRING_1)
				&& testArr.get(1).equals(STRING_2)
				&& testArr.get(2).equals(STRING_3)) {
			switch1 = true;
		}
		assertTrue(switch1);
	}

}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\units\StorageConfigTestUnit.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\units\StorageTaskTestUnit.java
	 */


public class StorageTaskTestUnit {

	private static final String TASK4_DESCRIPTION = "description4";
	private static final String STRING_VALUE_4 = "4";
	private static final String TASK4_NAME = "Task4";
	private static final String WEEKLY_VALUE = "weekly";
	private static final String TASK3_NAME = "Task3";
	private static final String STRING_VALUE_3 = "3";
	private static final String TASK2_DESCRIPTION = "description2";
	private static final String STRING_VALUE_2 = "2";
	private static final String TASK2_NAME = "Task2";
	private static final String TASK1_DESCRIPTION = "description1";
	private static final String STRING_VALUE_5 = "5";
	private static final String STRING_VALUE_1 = "1";
	private static final String TASK1_NAME = "Task1";
	private static final String EMPTY_STRING = "";
	private static final String TESTING_FILE = "testing.txt";

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		File f = new File(TESTING_FILE);
		f.delete();
	}
	
	/**
	 * Equivalence Partition: valid file name, empty file name, null file name
	 * Boundary Analysis: 0,1, more than 1 tasks
	 */


	/**
	 * Test for null filename
	 * 
	 * Equivalence partitioning: Null partition.
	 * Boundary Analysis:0
	 */
	@Test
	public void test1() {
		TaskList taskList = TaskList.getInstance();
		taskList.clear();
		TaskAndConfigStorage storeObj = TaskAndConfigStorage.getInstance();
		boolean result = storeObj.writeToFile(null, taskList);
		assertFalse(result);
	}
	/**
	 * Test for empty filename
	 * 
	 * Equivalence partitioning: Empty partition.
	 * Boundary Analysis:0
	 */
	@Test
	public void test2() {
		TaskList taskList = TaskList.getInstance();
		taskList.clear();
		TaskAndConfigStorage storeObj = TaskAndConfigStorage.getInstance();
		boolean result = storeObj.writeToFile(EMPTY_STRING, taskList);
		assertFalse(result);
	}

	/**
	 * Testing the case of an empty task list
	 * 
	 * Equivalence partitioning: valid file name.
	 * Boundary Analysis: 0
	 */
	@Test
	public void test3() {
		TaskList taskList = TaskList.getInstance();
		taskList.clear();
		TaskAndConfigStorage storeObj = TaskAndConfigStorage.getInstance();
		storeObj.writeToFile(TESTING_FILE, taskList);

		ArrayList<Object> tempArr = storeObj.readFromFile(TESTING_FILE);
		ArrayList<FloatTask> floatArr = (ArrayList<FloatTask>) tempArr.get(0);
		ArrayList<DeadLineTask> deadlineArr = (ArrayList<DeadLineTask>) tempArr
				.get(1);
		ArrayList<RepeatedTask> repeatArr = (ArrayList<RepeatedTask>) tempArr
				.get(2);

		assertTrue(floatArr.isEmpty() && deadlineArr.isEmpty()
				&& repeatArr.isEmpty());
	}

	/**
	 * Testing the case where there is 1 float task in TaskList
	 * 
	 * Combination:
	 * Equivalence partitioning: valid file name
	 * Boundary analysis: 1 float task, 0 deadline task, 0 repeated
	 */
	@Test
	public void test4() {
		boolean result = false;
		TaskList taskList = TaskList.getInstance();
		taskList.clear();
		taskList.add(new FloatTask(TASK1_NAME, STRING_VALUE_1, true, Calendar
				.getInstance(), STRING_VALUE_5, TASK1_DESCRIPTION, Calendar
				.getInstance(), Calendar.getInstance()));

		TaskAndConfigStorage storeObj = TaskAndConfigStorage.getInstance();
		storeObj.writeToFile(TESTING_FILE, taskList);

		ArrayList<Object> temp = storeObj.readFromFile(TESTING_FILE);
		ArrayList<FloatTask> floatArr = (ArrayList<FloatTask>) temp.get(0);
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskID().equals(floatArr.get(i).getTaskID())) {
				result = true;
			} else {
				result = false;
				break;
			}
		}
		assertTrue(result);
	}

	/**
	 * Testing the case where there is a mixture of 3 different type of tasks
	 * 
	 * Combination
	 * Equivalence partitioning: valid filename
	 * Boundary Analysis: 2 float tasks, 1 deadline task, 1 repeated task
	 */
	@Test
	public void test5() {
		/**
		 * boolean switch for each items in the TaskList
		 */
		boolean switch1 = false;
		boolean switch2 = false;
		boolean switch3 = false;
		boolean switch4 = false;

		/**
		 * Prepare the task object for the testing
		 */

		TaskList taskList = TaskList.getInstance();
		taskList.clear();
		ArrayList<Calendar> arrCal = new ArrayList<Calendar>();
		Calendar temp = Calendar.getInstance();
		temp.set(Calendar.YEAR, Calendar.DECEMBER, Calendar.MONDAY);
		arrCal.add(temp);
		taskList.add(new FloatTask(TASK1_NAME, STRING_VALUE_1, true, Calendar
				.getInstance(), STRING_VALUE_5, TASK1_DESCRIPTION, Calendar
				.getInstance(), Calendar.getInstance()));
		taskList.add(new DeadLineTask(TASK2_NAME, STRING_VALUE_2, false,
				Calendar.getInstance(), STRING_VALUE_1, TASK2_DESCRIPTION,
				Calendar.getInstance(), Calendar.getInstance(), Calendar
						.getInstance()));
		taskList.add(new RepeatedTask(TASK3_NAME, STRING_VALUE_3, true,
				Calendar.getInstance(), STRING_VALUE_2, TASK2_DESCRIPTION,
				Calendar.getInstance(), Calendar.getInstance(), WEEKLY_VALUE,
				arrCal, Calendar.getInstance(), 5));
		taskList.add(new FloatTask(TASK4_NAME, STRING_VALUE_4, true, Calendar
				.getInstance(), STRING_VALUE_1, TASK4_DESCRIPTION, Calendar
				.getInstance(), Calendar.getInstance()));

		/**
		 * Execute the writeToFile and readFromFile method
		 */
		TaskAndConfigStorage storeObj = TaskAndConfigStorage.getInstance();
		storeObj.writeToFile(TESTING_FILE, taskList);

		ArrayList<Object> tempArr = storeObj.readFromFile(TESTING_FILE);
		ArrayList<FloatTask> floatArr = (ArrayList<FloatTask>) tempArr.get(0);
		ArrayList<DeadLineTask> deadlineArr = (ArrayList<DeadLineTask>) tempArr
				.get(1);
		ArrayList<RepeatedTask> repeatArr = (ArrayList<RepeatedTask>) tempArr
				.get(2);

		/**
		 * Test if the boolean switch values to detect if there are any problems
		 * in both read and write methods.
		 * 
		 * TaskList will arrange the tasks such that FloatTask is in the first
		 * part of the array list, DeadLineTaask is in the second part of array
		 * list and repeatedTask is at the last part of the array list.
		 */
		if (taskList.get(0).getTaskID().equals(floatArr.get(0).getTaskID()))
			switch1 = true;
		if (taskList.get(2).getTaskID().equals(deadlineArr.get(0).getTaskID()))
			switch2 = true;
		if (taskList.get(3).getTaskID().equals(repeatArr.get(0).getTaskID()))
			switch3 = true;
		if (taskList.get(1).getTaskID().equals(floatArr.get(1).getTaskID()))
			switch4 = true;
		assertTrue(switch1 && switch2 && switch3 && switch4);

	}
}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\units\StorageTaskTestUnit.java





	/**
	 * origin: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\units\UndoTestUnit.java
	 */


public class UndoTestUnit {

	private static final String INVALID_CMD = "abc";
	private static final String EMPTY_STRING = "";
	private static final String WORKLOAD_CMD = "WORKLOAD";
	private static final String DATE_CMD = "DATE";
	private static final String EDIT_CMD = "EDIT";
	private static final String DELETE_CMD = "DELETE";
	private static final String ADD_CMD = "ADD";
	private static final int VALUE_5 = 5;
	private static final String WEEKLY_VALUE = "weekly";
	private static final String TASK2_NAME = "Task2";
	private static final String TASK3_DESCRIPTION = "description2";
	private static final String TASK3_NAME = "Task3";
	private static final String TASK1_DESCRIPTION = "description1";
	private static final String STRING_VALUE_2 = "2";
	private static final String STRING_VALUE_3 = "3";
	private static final String STRING_VALUE_1 = "1";
	/**
	 * viewUndoMethod 
	 * Equivalence partition: empty stack, not empty stack (more
	 * than 1 operationRecord object)
	 */
	/**
	 * inverseFunction 
	 * Equivalence partition: empty command, valid command,
	 * invalid command
	 */

	private static final String TASK1_NAME = "Task1";

	/**
	 * Testing viewUndo function of the Undo class 
	 * Equivalence partition:Stack<OperationRecord<Task,String>> is empty
	 */
	@Test
	public void test1() {
		Undo undoObj = new Undo();
		ArrayList<OperationRecord<Task, String>> result = undoObj.viewUndo();
		assertTrue(result.isEmpty());
	}

	/**
	 * Testing viewUndo function of the Undo class 
	 * Equivalence partition:Stack<OperationRecord<Task,String>> is not empty and contains
	 * more than 1 task.
	 */
	@Test
	public void test2() {
		/**
		 * Prepare all the data for testing
		 */
		Undo undoObj = new Undo();
		Calendar temp = Calendar.getInstance();
		temp.set(Calendar.YEAR, Calendar.DECEMBER, Calendar.MONDAY);
		ArrayList<Calendar> arrCal = new ArrayList<Calendar>();
		arrCal.add(temp);
		FloatTask floatTask = new FloatTask(TASK1_NAME, STRING_VALUE_1, true,
				Calendar.getInstance(), STRING_VALUE_3, TASK1_DESCRIPTION,
				Calendar.getInstance(), Calendar.getInstance());
		RepeatedTask repeatTask = new RepeatedTask(TASK3_NAME, STRING_VALUE_3,
				true, Calendar.getInstance(), STRING_VALUE_2,
				TASK3_DESCRIPTION, Calendar.getInstance(),
				Calendar.getInstance(), WEEKLY_VALUE, arrCal,
				Calendar.getInstance(), VALUE_5);
		DeadLineTask deadlineTask = new DeadLineTask(TASK2_NAME,
				STRING_VALUE_2, false, Calendar.getInstance(), STRING_VALUE_1,
				TASK3_DESCRIPTION, Calendar.getInstance(),
				Calendar.getInstance(), Calendar.getInstance());
		/**
		 * Testing
		 */
		undoObj.saveOperation(floatTask, ADD_CMD);
		undoObj.saveOperation(repeatTask, "DELTE");
		undoObj.saveOperation(deadlineTask, EDIT_CMD);

		ArrayList<OperationRecord<Task, String>> result = undoObj.viewUndo();
		boolean switch1 = false;
		boolean switch2 = false;
		boolean switch3 = false;
		if (result.get(0).getTask().equals(deadlineTask))
			switch1 = true;
		if (result.get(1).getTask().equals(repeatTask))
			switch2 = true;
		if (result.get(2).getTask().equals(floatTask))
			switch3 = true;
		assertTrue(switch1 && switch2 && switch3);

	}

	/**
	 * Testing inverseFuncton of Undo class 
	 * Equivalence Partition: empty command
	 */
	@Test
	public void test3() {
		boolean switch1 = false;
		Undo undoObj = new Undo();
		String result = undoObj.inverseFunction(EMPTY_STRING);
		if (result.isEmpty()) {
			switch1 = true;
		}
		assertTrue(switch1);
	}

	/**
	 * Testing inverseFunction of Undo class 
	 * Equivalence Partition: valid command
	 */
	@Test
	public void test4() {
		boolean switch1 = false;
		Undo undoObj = new Undo();
		String result = undoObj.inverseFunction(ADD_CMD);
		String result2 = undoObj.inverseFunction(DELETE_CMD);
		String result3 = undoObj.inverseFunction(EDIT_CMD);
		String result4 = undoObj.inverseFunction(DATE_CMD);
		String result5 = undoObj.inverseFunction(WORKLOAD_CMD);

		if (result.equals(DELETE_CMD) && result2.equals(ADD_CMD)
				&& result3.equals(EDIT_CMD) && result4.equals(EDIT_CMD)
				&& result5.equals(EDIT_CMD)) {
			switch1 = true;
		}
		assertTrue(switch1);
	}

	/**
	 * Testing inverseFunction of Undo class 
	 * Equivalence Partition: invalid command
	 */
	@Test
	public void test5() {
		boolean switch1 = false;
		Undo undoObj = new Undo();
		String result = undoObj.inverseFunction(INVALID_CMD);

		if (result.equals(EMPTY_STRING)) {
			switch1 = true;
		}
		assertTrue(switch1);
	}
}

	// End of segment: C:\Users\JiePing\workspace\CS2103T\src\taskaler\test\units\UndoTestUnit.java





